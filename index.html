<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ²‰æµ¸å¼èŠ‚æ—¥ç¥ç¦å¼•æ“ (Organic Ver.)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; color: white; font-family: sans-serif; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; transition: opacity 0.5s; font-weight: 300; letter-spacing: 2px; text-transform: uppercase; }
        #ui-layer { position: absolute; bottom: 40px; left: 0; width: 100%; text-align: center; pointer-events: none; z-index: 10; }
        .btn { pointer-events: auto; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); color: rgba(255,255,255,0.8); padding: 12px 30px; border-radius: 50px; cursor: pointer; backdrop-filter: blur(10px); transition: 0.4s; font-size: 12px; letter-spacing: 2px; }
        .btn:hover { background: rgba(255,255,255,0.2); color: #fff; box-shadow: 0 0 15px rgba(255,255,255,0.1); }
        #debug-info { position: absolute; top: 10px; left: 10px; color: rgba(255,255,255,0.2); font-size: 10px; pointer-events: none; font-family: monospace; }
    </style>
</head>
<body>

    <div id="loading">Planting the Tree...</div>
    <div id="debug-info"></div>
    
    <div id="ui-layer">
        <h1 id="theme-title" style="margin-bottom: 10px; font-weight: 100; font-size: 1.2rem; opacity: 0.9;">...</h1>
        <button id="sound-btn" class="btn">ğŸ”Š å¼€å¯æ°›å›´</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@supabase/supabase-js": "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { createClient } from '@supabase/supabase-js';

        // --- é…ç½®åŒº ---
        const SUPABASE_URL = 'https://tcviiqrcgijnxgwmzjkq.supabase.co';
        const SUPABASE_KEY = 'sb_publishable_VmvFMbF53RtgkovrckT_fQ_V9vh6yFS';
        
        const debugEl = document.getElementById('debug-info');
        const titleEl = document.getElementById('theme-title');
        const loadingEl = document.getElementById('loading');

        // --- åœºæ™¯ ---
        const scene = new THREE.Scene();
        // æ›´åŠ æ·±é‚ƒçš„èƒŒæ™¯é›¾ï¼Œæ¨¡æ‹Ÿå¤œé—´æ£®æ—
        scene.fog = new THREE.FogExp2(0x020202, 0.035);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 16); // è§†è§’æ”¾å¹³ï¼Œçœ‹å…¨è²Œ

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.maxDistance = 25;
        controls.minDistance = 2;

        // --- æ ¸å¿ƒä¿®æ”¹ï¼šæœ‰æœºæ ‘ç”Ÿæˆç®—æ³• ---
        let treeSystem;

        function createTree(config) {
            if(treeSystem) scene.remove(treeSystem);

            // è¯»å–é…ç½®æˆ–ä½¿ç”¨é»˜è®¤å€¼
            const count = config.visual.particleCount || 4000; // å¢åŠ ç²’å­æ•°ä»¥è·å¾—èŒ‚å¯†æ„Ÿ
            const primaryHex = config.visual.primaryColor || '#2E8B57'; // é»˜è®¤æ ‘å¶ç»¿
            const secondaryHex = config.visual.secondaryColor || '#FFD700'; // é»˜è®¤ç¯å…‰é‡‘
            
            const colorLeaf = new THREE.Color(primaryHex); 
            const colorLight = new THREE.Color(secondaryHex);

            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const randoms = []; // ç”¨äºåŠ¨ç”»çš„éšæœºç›¸ä½

            // ç®—æ³•ï¼šåˆ†å±‚å †å  + æå¶å™ªå£°
            const layers = 18; // æ ‘çš„å±‚æ•°
            const particlesPerLayer = Math.floor(count / layers);

            for (let l = 0; l < layers; l++) {
                // å½“å‰å±‚çš„é«˜åº¦è¿›åº¦ (0 = é¡¶ç«¯, 1 = åº•ç«¯)
                const t = l / (layers - 1); 
                const layerY = 6 - (t * 12); // ä» +6 åˆ° -6
                
                // æ¯ä¸€å±‚çš„æœ€å¤§åŠå¾„ (ä¸Šé¢çª„ï¼Œä¸‹é¢å®½ï¼Œå‘ˆæŒ‡æ•°æ›²çº¿)
                const maxRadius = 0.2 + (t * t * 5.5); 

                for (let i = 0; i < particlesPerLayer; i++) {
                    // åœ¨è¿™ä¸€å±‚é‡Œç”Ÿæˆç²’å­
                    // å…³é”®ï¼šä¸å‡åŒ€åˆ†å¸ƒã€‚è§’åº¦è¦èšæ‹¢ï¼Œæ¨¡æ‹Ÿæ ‘æ
                    const angleBase = (Math.PI * 2 * i) / particlesPerLayer;
                    // åŠ å…¥ä¸€ç‚¹æ­£å¼¦æ³¢æ‰°åŠ¨ï¼Œè®©æ¯ä¸€å±‚åƒèŠ±ç“£ä¸€æ ·æœ‰å‡¹å‡¸
                    const branchNoise = Math.sin(angleBase * 5); // 5ä¸ªä¸»åˆ†å‰
                    
                    const r = Math.random() * maxRadius * (0.8 + 0.2 * branchNoise);
                    const angle = Math.random() * Math.PI * 2;

                    // æœ€ç»ˆä½ç½®
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    // Yè½´å¢åŠ éšæœºåšåº¦ï¼Œä¸è¦åƒçº¸ç‰‡ä¸€æ ·è–„
                    const y = layerY - (Math.random() * 0.8) + (Math.abs(x)*0.2); // æ ‘æè‡ªç„¶ä¸‹å‚æ•ˆæœ

                    positions.push(x, y, z);
                    randoms.push(Math.random());

                    // é¢œè‰²åˆ†é…ï¼šå†…éƒ¨æ˜¯æš—ç»¿ï¼Œè¾¹ç¼˜æ˜¯äº®è‰²/ç¯å…‰
                    const distFromCenter = Math.sqrt(x*x + z*z) / maxRadius;
                    
                    if (Math.random() > 0.92 && distFromCenter > 0.5) {
                        // 8% çš„æ¦‚ç‡ç”Ÿæˆâ€œå½©ç¯â€ï¼Œä¸”åªæŒ‚åœ¨æ ‘æ¢¢å¤–éƒ¨
                        colors.push(colorLight.r, colorLight.g, colorLight.b);
                        sizes.push(0.3 + Math.random() * 0.3); // ç¯å¤§ä¸€ç‚¹
                    } else {
                        // æ ‘å¶ç²’å­
                        // è¶Šé å¤–è¶Šäº®ï¼Œè¶Šé é‡Œè¶Šæš—ï¼ˆæ¨¡æ‹Ÿå…‰ç…§é®è”½ï¼‰
                        const leafColor = colorLeaf.clone().multiplyScalar(0.5 + distFromCenter * 0.5);
                        colors.push(leafColor.r, leafColor.g, leafColor.b);
                        sizes.push(0.1 + Math.random() * 0.1); // å¶å­å°ä¸€ç‚¹
                    }
                }
            }

            // é¡¶éƒ¨çš„æ˜Ÿæ˜Ÿ (é¢å¤–åŠ ä¸€ä¸ªå¤§ç‚¹)
            positions.push(0, 6.2, 0);
            colors.push(1, 1, 0.8); // äº®ç™½é‡‘
            sizes.push(0.8);
            randoms.push(0);

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));

            // æè´¨
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pointTexture: { value: new THREE.TextureLoader().load('https://assets.codepen.io/127738/dotTexture.png') } // ä½¿ç”¨ä¸€ä¸ªç®€å•çš„è¾‰å…‰è´´å›¾
                },
                vertexShader: `
                    attribute float size;
                    attribute float aRandom;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    void main() {
                        vColor = color;
                        vec3 pos = position;
                        
                        // é£å¹æ•ˆæœï¼šé«˜åº¦è¶Šé«˜ï¼Œæ™ƒåŠ¨è¶Šå¤§
                        float windStrength = max(0.0, pos.y + 5.0) * 0.1;
                        pos.x += sin(time * 1.5 + pos.y) * windStrength * 0.2;
                        pos.z += cos(time * 1.2 + pos.y) * windStrength * 0.2;

                        // å‘¼å¸å¾‹åŠ¨
                        if(color.r > 0.8) { // å¦‚æœæ˜¯ç¯å…‰ï¼ˆçº¢è‰²åˆ†é‡é«˜ï¼‰
                            float blink = sin(time * 3.0 + aRandom * 10.0);
                            pos *= 1.0 + (blink * 0.02); // è½»å¾®ç¼©æ”¾
                        }

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        // ç®€å•çš„åœ†å½¢è¾‰å…‰ç»˜åˆ¶ (æ— éœ€å¤–éƒ¨è´´å›¾ä¹Ÿèƒ½è·‘ï¼Œä½†ä¸ºäº†æ•ˆæœè¿™é‡Œæ¨¡æ‹Ÿä¸€ä¸‹)
                        float d = distance(gl_PointCoord, vec2(0.5));
                        if(d > 0.5) discard;
                        
                        // è¾¹ç¼˜æŸ”åŒ–
                        float alpha = 1.0 - smoothstep(0.3, 0.5, d);
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            treeSystem = new THREE.Points(geometry, material);
            scene.add(treeSystem);
        }

        // --- æ•°æ®ä¸é€»è¾‘ ---
        async function initEngine() {
            // é»˜è®¤è§†è§‰é…ç½® (å†·æ‰ç»¿ + æš–é‡‘)
            const fallbackConfig = {
                name: "é»˜è®¤ï¼šåŒ—æ¬§å†·æ‰",
                config: {
                    visual: { primaryColor: '#2E8B57', secondaryColor: '#FFD700', particleCount: 5000 }
                }
            };

            try {
                debugEl.innerText = "Connecting...";
                const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);
                
                const { data, error } = await supabase
                    .from('themes')
                    .select('*')
                    .eq('is_active', true)
                    .maybeSingle();

                if (error || !data) throw new Error("DB Fetch Error");

                debugEl.innerText = "";
                titleEl.innerText = data.name;
                createTree(data.config);

            } catch (err) {
                console.warn(err);
                debugEl.innerText = "Offline Mode";
                titleEl.innerText = fallbackConfig.name;
                createTree(fallbackConfig.config);
            }
            loadingEl.style.opacity = 0;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const time = Date.now() * 0.001;
            
            if (treeSystem) {
                // æ›´æ–° Shader æ—¶é—´å˜é‡
                treeSystem.material.uniforms.time.value = time;
                // ç¼“æ…¢è‡ªè½¬
                treeSystem.rotation.y = time * 0.1; 
            }
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initEngine();
        animate();
    </script>
</body>
</html>
