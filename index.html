<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Holiday Wishes</title>
    <style>
        /* 简单的 CSS 重置，确保全屏显示 */
        body { margin: 0; padding: 0; overflow: hidden; background-color: #050505; font-family: 'Arial', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* 加载动画 */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 14px; letter-spacing: 2px; pointer-events: none; transition: opacity 0.5s;
        }

        /* 简单的 UI 层，未来放文字 */
        #ui-layer {
            position: absolute; bottom: 50px; left: 0; width: 100%; text-align: center;
            color: rgba(255,255,255,0.8); pointer-events: none; user-select: none;
        }
        h1 { margin: 0; font-weight: 300; font-size: 24px; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>

    <div id="loading">正在连接节日数据库...</div>
    <div id="canvas-container"></div>
    <div id="ui-layer">
        <h1 id="greeting-text">Loading...</h1>
    </div>

    <script type="module">
        // ================= 配置区域 (只有这里需要你确认) =================
        const PROJECT_URL = 'https://flpenzppjhbcggsjivpl.supabase.co'; // 你提供的 URL
        const PUBLIC_KEY = 'sb_publishable_RpdtozDQF183fr6HkRsd6A_xNXfsy0n'; // 你提供的 Key

        // 初始化 Supabase
        const supabase = window.supabase.createClient(PROJECT_URL, PUBLIC_KEY);

        // ================= 核心逻辑 =================
        let scene, camera, renderer, particlesMesh;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        
        // 默认参数 (如果数据库断连，用这些保底)
        let config = {
            particleCount: 3000,
            particleSize: 2.5,
            color: '#00ff00',
            shape: 'tree' // tree, sphere
        };

        // 1. 从数据库获取配置和节日
        async function initData() {
            const loading = document.getElementById('loading');
            try {
                // 并行获取配置和节日
                const [configRes, festivalsRes] = await Promise.all([
                    supabase.from('app_configs').select('*'),
                    supabase.from('festivals').select('*')
                ]);

                // 解析全局配置
                if (configRes.data) {
                    configRes.data.forEach(item => {
                        if (item.key === 'particle_count') config.particleCount = Number(item.value);
                        if (item.key === 'particle_size') config.particleSize = Number(item.value);
                    });
                }

                // 判断今天是哪个节日
                const today = new Date();
                const month = today.getMonth() + 1;
                const day = today.getDate();
                const dateStr = `${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
                
                // 简单的日期匹配逻辑
                let currentTheme = null;
                if (festivalsRes.data) {
                    // 优先找当前日期的节日
                    currentTheme = festivalsRes.data.find(f => {
                        return dateStr >= f.start_date && dateStr <= f.end_date && f.active;
                    });
                    // 如果没找到，找默认配置
                    if (!currentTheme) {
                        currentTheme = festivalsRes.data.find(f => f.slug === 'default');
                    }
                }

                if (currentTheme) {
                    config.color = currentTheme.primary_color;
                    config.shape = currentTheme.shape_type;
                    document.getElementById('greeting-text').innerText = `${currentTheme.name} Mode`;
                }

                loading.style.opacity = 0;
                initVisuals(); // 数据有了，开始渲染

            } catch (error) {
                console.error("Database Error:", error);
                loading.innerText = "离线模式 (数据库连接失败)";
                setTimeout(() => { loading.style.opacity = 0; initVisuals(); }, 1000);
            }
        }

        // 2. 初始化视觉场景
        function initVisuals() {
            const container = document.getElementById('canvas-container');

            // 场景
            scene = new THREE.Scene();
            // 加上一点迷雾效果，更有氛围
            scene.fog = new THREE.FogExp2(0x050505, 0.0008);

            // 相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.z = 1000;

            // 渲染器
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // 创建粒子
            createParticles();

            // 事件监听
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('touchstart', onDocumentTouchStart, false);
            document.addEventListener('touchmove', onDocumentTouchMove, false);
            window.addEventListener('resize', onWindowResize, false);

            // 开始动画循环
            animate();
        }

        // 3. 核心：创建粒子形状
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            const colorObj = new THREE.Color(config.color);

            for (let i = 0; i < config.particleCount; i++) {
                let x, y, z;

                if (config.shape === 'tree') {
                    // --- 圣诞树算法 ---
                    // 螺旋上升算法：y从下到上，半径r随y减小
                    const yPos = (Math.random() * 1000) - 500; // 高度范围 -500 到 500
                    const radius = (500 - yPos) * 0.4 * Math.random(); // 底部宽，顶部尖
                    const angle = Math.random() * Math.PI * 2; // 360度随机

                    x = Math.cos(angle) * radius;
                    y = yPos;
                    z = Math.sin(angle) * radius;

                    // 加一点随机噪点，让树看起来自然蓬松，不是完美的圆锥
                    x += (Math.random() - 0.5) * 50;
                    z += (Math.random() - 0.5) * 50;
                } else {
                    // --- 球体/默认算法 ---
                    const r = 600 * Math.random();
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }

                positions.push(x, y, z);
                colors.push(colorObj.r, colorObj.g, colorObj.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // 材质
            const material = new THREE.PointsMaterial({
                size: config.particleSize,
                vertexColors: true,
                blending: THREE.AdditiveBlending, // 发光叠加效果
                depthTest: false,
                transparent: true,
                opacity: 0.8
            });

            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);
        }

        // 4. 交互与动画
        function onDocumentMouseMove(event) {
            mouseX = event.clientX - windowHalfX;
            mouseY = event.clientY - windowHalfY;
        }

        function onDocumentTouchStart(event) {
            if (event.touches.length === 1) {
                event.preventDefault(); // 防止滚动
                mouseX = event.touches[0].pageX - windowHalfX;
                mouseY = event.touches[0].pageY - windowHalfY;
            }
        }

        function onDocumentTouchMove(event) {
            if (event.touches.length === 1) {
                event.preventDefault();
                mouseX = event.touches[0].pageX - windowHalfX;
                mouseY = event.touches[0].pageY - windowHalfY;
            }
        }

        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            // 自动缓慢旋转
            particlesMesh.rotation.y += 0.002; 

            // 鼠标交互：根据鼠标位置改变相机角度
            // 目标位置 = 鼠标位置 * 灵敏度
            targetRotationX = mouseX * 0.001;
            targetRotationY = mouseY * 0.001;

            // 缓动效果：当前位置 += (目标位置 - 当前位置) * 0.05
            particlesMesh.rotation.y += 0.05 * (targetRotationX - particlesMesh.rotation.y);
            particlesMesh.rotation.x += 0.05 * (targetRotationY - particlesMesh.rotation.x);

            // 粒子闪烁动画 (可选：如果想让树看起来在呼吸)
            // const time = Date.now() * 0.005;
            // particlesMesh.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // 启动！
        initData();

    </script>
</body>
</html>
