<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ²‰æµ¸å¼èŠ‚æ—¥å¼•æ“ (Magnetic Field)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #loading { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            color: rgba(255,255,255,0.5); font-family: sans-serif; letter-spacing: 2px; pointer-events: none;
        }
        #ui-container {
            position: absolute; bottom: 40px; width: 100%; text-align: center; pointer-events: none;
        }
        .btn { 
            pointer-events: auto; background: rgba(255,255,255,0.1); 
            border: 1px solid rgba(255,255,255,0.3); color: #fff; 
            padding: 15px 40px; border-radius: 50px; cursor: pointer; 
            font-size: 14px; text-transform: uppercase; letter-spacing: 1px;
            backdrop-filter: blur(10px); transition: 0.2s;
        }
        .btn:hover { background: rgba(255,255,255,0.3); box-shadow: 0 0 20px rgba(255,255,255,0.2); }
        .btn:active { transform: scale(0.95); }
    </style>
</head>
<body>

    <div id="loading">BUILDING VISUALS...</div>
    <div id="ui-container">
        <button id="sound-btn" class="btn">ğŸ”´ ç‚¹å‡»å¼€å¯å£°éŸ³ä¸é­”æ³•</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "@supabase/supabase-js": "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { createClient } from '@supabase/supabase-js';

        // --- 1. åˆå§‹åŒ–åœºæ™¯ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        // æ‘„åƒæœºå›ºå®šï¼Œä¸å†ä¹±è½¬
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 14); 
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 2. äº¤äº’æ ¸å¿ƒï¼šé¼ æ ‡/è§¦æ‘¸è¿½è¸ª ---
        const mouse = new THREE.Vector2(9999, 9999); // åˆå§‹ä½ç½®åœ¨å±å¹•å¤–
        const raycaster = new THREE.Raycaster();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // è™šæ‹Ÿå¹³é¢ï¼Œç”¨äºæ•æ‰é¼ æ ‡åœ¨3Dç©ºé—´çš„ä½ç½®
        const target3D = new THREE.Vector3();

        function updateMouse(event) {
            let x, y;
            if (event.changedTouches) {
                x = event.changedTouches[0].clientX;
                y = event.changedTouches[0].clientY;
            } else {
                x = event.clientX;
                y = event.clientY;
            }
            // å½’ä¸€åŒ–åæ ‡ (-1 åˆ° +1)
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;

            // è®¡ç®—é¼ æ ‡åœ¨ Z=0 å¹³é¢ä¸Šçš„ 3D åæ ‡
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(plane, target3D);
        }

        window.addEventListener('mousemove', updateMouse);
        window.addEventListener('touchmove', updateMouse, { passive: false });

        // --- 3. ç²’å­ç³»ç»Ÿ (GPU Shader) ---
        // å…³é”®ï¼šæ‰€æœ‰åŠ¨ç”»éƒ½åœ¨æ˜¾å¡é‡Œç®—ï¼Œä¸æ¶ˆè€— CPUï¼Œæ‰èƒ½æµç•…å¤„ç† 20000 ä¸ªç‚¹
        
        // é¡¶ç‚¹ç€è‰²å™¨ï¼šæ§åˆ¶ä½ç½®ã€å¤§å°ã€ç£åœºå¹²æ‰°
        const vertexShader = `
            uniform float uTime;
            uniform vec3 uMouse;
            uniform float uAudio;
            
            attribute float size;
            attribute vec3 originPos; // åŸå§‹ä½ç½®ï¼ˆè®°å¿†ï¼‰
            attribute float aRandom;  // éšæœºå› å­

            varying vec3 vColor;

            void main() {
                vec3 pos = originPos;

                // 1. åŸºç¡€å‘¼å¸ (éšæ—¶é—´å¾®åŠ¨)
                pos.y += sin(uTime * 2.0 + pos.x) * 0.05;

                // 2. ç£åœºå¹²æ‰° (æ ¸å¿ƒäº¤äº’)
                // è®¡ç®—ç²’å­åˆ°é¼ æ ‡çš„è·ç¦»
                float dist = distance(pos.xy, uMouse.xy);
                float radius = 2.5; // ç£åœºåŠå¾„
                
                if(dist < radius) {
                    // åŠ›çš„æ–¹å‘ï¼šä»é¼ æ ‡æŒ‡å‘ç²’å­ (æ’æ–¥)
                    vec3 dir = normalize(pos - uMouse);
                    float force = (radius - dist) / radius; // è¶Šè¿‘åŠ›è¶Šå¤§
                    
                    // ç±»ä¼¼çˆ†ç‚¸æ¨å¼€
                    pos += dir * force * 3.0; 
                    
                    // ç¢°åˆ°çš„ç²’å­å˜å¤§ã€å˜äº®
                    gl_PointSize = size * (1.0 + force * 5.0 + uAudio * 0.5) * (300.0 / -mvPosition.z);
                    vColor = vec3(1.0, 0.9, 0.5); // å˜æˆç«èŠ±è‰²
                } else {
                    // æ²¡ç¢°åˆ°å°±æ˜¯åŸæ ·
                    gl_PointSize = size * (1.0 + uAudio * 0.2) * (300.0 / -mvPosition.z);
                    vColor = color;
                }
                
                // 3. å£°éŸ³éœ‡åŠ¨
                pos.x += sin(uTime * 10.0 + pos.y) * uAudio * 0.1;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            void main() {
                // åœ†å½¢ç²’å­ç»˜åˆ¶
                float d = distance(gl_PointCoord, vec2(0.5));
                if(d > 0.5) discard;
                
                // ä¸­å¿ƒäº®ï¼Œè¾¹ç¼˜æš—
                float alpha = 1.0 - smoothstep(0.1, 0.5, d);
                gl_FragColor = vec4(vColor, alpha * 0.8);
            }
        `;

        // --- 4. ç”ŸæˆçœŸæ­£çš„æ ‘å½¢ ---
        function generateTree() {
            const particleCount = 20000;
            const geometry = new THREE.BufferGeometry();
            
            const positions = [];
            const origins = [];
            const colors = [];
            const sizes = [];
            const randoms = [];

            const colorGreen = new THREE.Color('#1a5c20'); // æ·±ç»¿
            const colorBright = new THREE.Color('#4caf50'); // å«©ç»¿
            const colorTrunk = new THREE.Color('#3e2723'); // æ ‘å¹²è¤

            for(let i = 0; i < particleCount; i++) {
                let x, y, z, r, g, b, s;

                // 90% æ˜¯æ ‘å¶ï¼Œ10% æ˜¯æ ‘å¹²
                if (i < particleCount * 0.9) {
                    // æ ‘å¶ï¼šåœ†é”¥ä½“åˆ†å¸ƒ
                    // é«˜åº¦ -4 åˆ° 6
                    const h = Math.random() * 10 - 4; 
                    // åŠå¾„éšé«˜åº¦å˜å° (çº¿æ€§æ”¶ç¼©)
                    const maxR = (6 - h) * 0.45; 
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * maxR;

                    x = Math.cos(angle) * radius;
                    y = h;
                    z = Math.sin(angle) * radius;

                    // é¢œè‰²æ‚ä¹±åº¦
                    const mix = Math.random();
                    const c = colorGreen.clone().lerp(colorBright, Math.pow(mix, 3));
                    r = c.r; g = c.g; b = c.b;
                    s = Math.random() * 0.15 + 0.05;
                } else {
                    // æ ‘å¹²ï¼šåœ†æŸ±ä½“
                    const h = Math.random() * 5 - 5; // -5 åˆ° 0
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 0.5;

                    x = Math.cos(angle) * radius;
                    y = h;
                    z = Math.sin(angle) * radius;

                    r = colorTrunk.r; g = colorTrunk.g; b = colorTrunk.b;
                    s = 0.2;
                }

                positions.push(x, y, z);
                origins.push(x, y, z); // è®°å½•åŸå§‹ä½ç½®ç”¨äºå›å¼¹
                colors.push(r, g, b);
                sizes.push(s);
                randoms.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('originPos', new THREE.Float32BufferAttribute(origins, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uMouse: { value: new THREE.Vector3(99, 99, 0) },
                    uAudio: { value: 0 }
                },
                vertexShader: vertexShader.replace('mvPosition', 'mvPosition'), // Hack to ensure scope
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const points = new THREE.Points(geometry, material);
            scene.add(points);
            return points;
        }

        const tree = generateTree();
        document.getElementById('loading').style.display = 'none';

        // --- 5. å£°éŸ³ç³»ç»Ÿ (AudioContext) ---
        let analyser, dataArray, audioContext;
        const btn = document.getElementById('sound-btn');

        async function initAudio() {
            // å¿…é¡»åœ¨ç”¨æˆ·ç‚¹å‡»ååˆ›å»º AudioContext
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const audio = new Audio();
            audio.crossOrigin = "anonymous";
            // ç»å…¸çš„åœ£è¯èƒŒæ™¯éŸ³ä¹
            audio.src = "https://actions.google.com/sounds/v1/holidays/deck_the_halls.ogg"; 
            audio.loop = true;

            const source = audioContext.createMediaElementSource(audio);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            
            await audio.play();
            btn.innerText = "ğŸ”Š éŸ³ä¹å·²å¼€å¯ (é¼ æ ‡åˆ’è¿‡æ ‘æœ¨)";
            btn.style.opacity = 0.5;
        }

        btn.addEventListener('click', () => {
            if (!audioContext) {
                initAudio().catch(e => {
                    btn.innerText = "âŒ æ’­æ”¾å¤±è´¥: " + e.message;
                });
            }
        });

        // --- 6. æ¸²æŸ“å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now() * 0.001;
            
            // æ›´æ–° Shader å‚æ•°
            tree.material.uniforms.uTime.value = time;
            tree.material.uniforms.uMouse.value = target3D; // ä¼ å…¥è½¬æ¢åçš„é¼ æ ‡3Dåæ ‡

            // éŸ³é¢‘å“åº”
            if (analyser) {
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(dataArray);
                // å–ä½é¢‘éƒ¨åˆ†çš„å¹³å‡å€¼ä½œä¸ºéœ‡åŠ¨å¼ºåº¦
                const avg = dataArray.slice(0, 30).reduce((a, b) => a + b, 0) / 30;
                // å½’ä¸€åŒ–åˆ° 0 - 1
                tree.material.uniforms.uAudio.value = THREE.MathUtils.lerp(tree.material.uniforms.uAudio.value, avg / 128, 0.1);
            }

            renderer.render(scene, camera);
        }

        animate();

        // çª—å£è‡ªé€‚åº”
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
