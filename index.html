<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magic Holiday Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Noto+Serif+SC:wght@500&display=swap" rel="stylesheet">
    
    <style>
        /* === è§†è§‰åŸºç¡€ === */
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Noto Serif SC', serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* === UI å¸ƒå±€ (åº•éƒ¨æ²‰æµ¸å¼) === */
        #ui-layer {
            position: absolute; bottom: 0; left: 0; width: 100%; 
            padding-bottom: 40px; /* åº•éƒ¨ç•™ç™½ */
            z-index: 10; pointer-events: none; /* ç©¿é€ */
            display: flex; flex-direction: column; 
            align-items: center; justify-content: flex-end;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 100%); /* åº•éƒ¨æ¸å˜é®ç½©ï¼Œé˜²æ­¢æ–‡å­—çœ‹ä¸æ¸… */
            height: 40%; /* é®ç½©é«˜åº¦ */
        }

        /* ç¥ç¦å¡ç‰‡ */
        #wish-card {
            margin-bottom: 25px;
            padding: 12px 30px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(8px); /* é«˜çº§ç£¨ç ‚ */
            border-radius: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center;
            opacity: 0; animation: fadeInUp 1.5s ease-out forwards 0.5s;
            max-width: 90%;
        }
        
        #wish-text {
            color: #ffeebb; /* é¦™æ§Ÿé‡‘ */
            font-family: 'Dancing Script', cursive; 
            font-size: 2rem; 
            margin: 0; line-height: 1.2;
            text-shadow: 0 0 15px rgba(255, 200, 80, 0.6);
        }

        /* åˆ¶ä½œæŒ‰é’® (å¹½çµæŒ‰é’®é£æ ¼) */
        #create-btn {
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 24px;
            font-size: 13px; border-radius: 30px;
            cursor: pointer; pointer-events: auto;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            text-transform: uppercase; letter-spacing: 2px;
        }
        #create-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff; border-color: #fff;
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
        }

        /* === å¼¹çª— (æ·±è‰²æ‹Ÿæ€) === */
        #modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9);
            width: 85%; max-width: 360px;
            background: #111; 
            padding: 30px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.15); z-index: 100;
            display: none; pointer-events: auto;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            opacity: 0; transition: all 0.3s;
        }
        #modal.active { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        
        .close-btn { position: absolute; top: 20px; right: 20px; color: #666; cursor: pointer; font-size: 20px; }
        
        label { color: #888; font-size: 12px; display: block; margin: 15px 0 5px; letter-spacing: 1px; }
        input, select, textarea {
            width: 100%; padding: 12px; 
            background: #1a1a1a; border: 1px solid #333; 
            color: #eee; border-radius: 8px; box-sizing: border-box; outline: none;
            transition: border-color 0.3s;
        }
        input:focus, select:focus, textarea:focus { border-color: #ffcc00; }
        
        button.submit-btn {
            width: 100%; padding: 14px; margin-top: 25px;
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);
            color: #333; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;
            font-size: 16px;
        }

        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: rgba(255,255,255,0.3); font-size: 12px; z-index: 5; }
        
        .required-mark { color: #ff4466; margin-left: 5px; }
    </style>
    
    <script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="wish-card"><h1 id="wish-text">Connecting...</h1></div>
        <button id="create-btn" onclick="ui.openModal()">æˆ‘ä¹Ÿè¦åˆ¶ä½œ</button>
    </div>

    <div id="modal">
        <div class="close-btn" onclick="ui.closeModal()">âœ•</div>
        <h3 style="margin: 0; color:#fff; text-align: center; font-weight: 300; letter-spacing: 2px;">å®šåˆ¶ç¥ç¦</h3>
        
        <label>å¯¹æ–¹åå­— <span class="required-mark">*</span></label>
        <input type="text" id="input-name" placeholder="Name">
        
        <label>é€‰æ‹©ä¸»é¢˜</label>
        <select id="input-theme" onchange="ui.onThemeChange()">
            <option value="1">ğŸ„ ç»å…¸åœ£è¯æ ‘</option>
            <option value="2">ğŸ® æ˜¥èŠ‚çº¢ç¯ç¬¼</option>
            <option value="3">ğŸ‚ ç”Ÿæ—¥å¤§è›‹ç³•</option>
            <option value="4">ğŸ’– æµªæ¼«ç²‰çˆ±å¿ƒ</option>
        </select>

        <label id="label-date">æ—¥æœŸ (å¦‚æœæ˜¯ç”Ÿæ—¥åˆ™å¿…å¡«)</label>
        <input type="text" id="input-date" placeholder="MM-DD (å¦‚ 12-25)">
        
        <label>ç¥ç¦è¯­ (ç•™ç©ºåˆ™éšæœº)</label>
        <textarea id="input-wish" rows="2" placeholder="å†™ä¸€å¥æš–å¿ƒçš„è¯..."></textarea>
        
        <button class="submit-btn" onclick="ui.submitForm()">ç”Ÿæˆä¸“å±é“¾æ¥</button>
        <div id="result-link" style="margin-top:15px; word-break: break-all; color: #ffcc00; font-size: 12px; text-align: center;"></div>
    </div>

    <div id="loading">...</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // === å…¨å±€é…ç½® ===
        const CONFIG = {
            supabaseUrl: 'https://tcviiqrcgijnxgwmzjkq.supabase.co',
            supabaseKey: 'sb_publishable_VmvFMbF53RtgkovrckT_fQ_V9vh6yFS',
            particleCount: 7000, // å¢åŠ ç²’å­å¯†åº¦
            sparkCount: 500      // ç«èŠ±æ± å¤§å°
        };

        const supabase = window.supabase.createClient(CONFIG.supabaseUrl, CONFIG.supabaseKey);

        let scene, camera, renderer, particles, sparkParticles;
        let controls, audioCtx, analyser, dataArray;
        let isAudioInit = false;
        
        // äº¤äº’ä¸“ç”¨
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let mouse3D = new THREE.Vector3();
        let planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); 
        let isInteracting = false;
        let lastMouse3D = new THREE.Vector3(); // ç”¨äºè®¡ç®—é¼ æ ‡ç§»åŠ¨é€Ÿåº¦

        // æ•°æ®å®¹å™¨
        let particleData = []; 
        let sparkData = []; // ç«èŠ±ç‰©ç†æ•°æ®

        init();

        async function init() {
            // 1. åˆå§‹åŒ–åœºæ™¯
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02); // é»‘è‰²é›¾æ°”

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 25); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0); // ç¡®ä¿é€æ˜
            container.appendChild(renderer.domElement);

            // 2. æ§åˆ¶å™¨ (é”å®šè§†è§’ï¼Œä»…å…è®¸è‡ªè½¬)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;     
            controls.autoRotateSpeed = 1.0; 
            controls.enableRotate = false; // ç¦æ­¢ç”¨æˆ·ä¹±åŠ¨è§†è§’
            controls.enableZoom = false;    
            controls.enablePan = false;     

            // 3. åˆ›å»ºç³»ç»Ÿ
            createMainParticles();
            createPhysicsSparks(); // ç‰©ç†ç«èŠ±ç³»ç»Ÿ

            // 4. äº‹ä»¶
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMove);
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('pointerdown', () => {
                if (!isAudioInit) { initAudio(); isAudioInit = true; }
            });

            animate();
            await loadContentLogic();
        }

        // === æ ¸å¿ƒï¼šè¯»å–æ•°æ®åº“ ===
        async function loadContentLogic() {
            const params = new URLSearchParams(window.location.search);
            const toUser = params.get('to');
            const today = getFormattedDate();

            let finalTheme = null, finalWish = "";

            // ä¼˜å…ˆæŸ¥ç§äººå®šåˆ¶
            if (toUser) {
                const { data } = await supabase.from('private_events').select('*, themes(*)').eq('user_key', toUser);
                if (data && data.length > 0) {
                    finalTheme = data[0].themes;
                    finalWish = data[0].custom_message;
                }
            }
            // å…¶æ¬¡æŸ¥èŠ‚æ—¥
            if (!finalTheme) {
                const { data } = await supabase.from('public_holidays').select('*, themes(*)').lte('start_date', today).gte('end_date', today);
                if (data && data.length > 0) {
                    finalTheme = data[0].themes;
                    finalWish = data[0].wish_text;
                }
            }
            // é»˜è®¤
            if (!finalTheme) {
                finalTheme = { model_type: 'tree', particle_color: '#00ff00' };
                finalWish = "Merry Christmas";
            }

            // å¤„ç†å¤šæ¡ç¥ç¦è¯­é€»è¾‘ (| åˆ†å‰²)
            if (finalWish && finalWish.includes('|')) {
                const arr = finalWish.split('|');
                finalWish = arr[Math.floor(Math.random() * arr.length)];
            } else if (!finalWish) {
                finalWish = "Best Wishes For You";
            }

            // åº”ç”¨
            document.getElementById('wish-text').innerText = finalWish;
            document.getElementById('loading').style.display = 'none';
            generateShape(finalTheme.model_type || 'tree', themeToColor(finalTheme));
        }

        function themeToColor(theme) { return theme.particle_color || '#00ff00'; }

        // === ç³»ç»Ÿ 1: ä¸»ä½“ç²’å­ (æ ‘/ç¯ç¬¼) ===
        function createMainParticles() {
            const geometry = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.particleCount * 3);
            const col = new Float32Array(CONFIG.particleCount * 3);
            
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));

            const material = new THREE.PointsMaterial({
                size: 0.35, vertexColors: true, blending: THREE.AdditiveBlending,
                depthWrite: false, transparent: true, opacity: 0.8,
                map: createGlowTexture()
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // åˆå§‹åŒ–å®¹å™¨
            for(let i=0; i<CONFIG.particleCount; i++) {
                particleData.push({
                    home: new THREE.Vector3(), // ç›®æ ‡ä½ç½®
                    baseColor: new THREE.Color(),
                    velocity: new THREE.Vector3(),
                    isOrnament: false
                });
            }
        }

        // === ç³»ç»Ÿ 2: ç‰©ç†ç«èŠ± (ä¸å†æ˜¯è´´å›¾åŠ¨ç”»ï¼Œè€Œæ˜¯çœŸå®çš„ç‰©ç†æ¨¡æ‹Ÿ) ===
        function createPhysicsSparks() {
            const geometry = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.sparkCount * 3);
            const col = new Float32Array(CONFIG.sparkCount * 3);
            const size = new Float32Array(CONFIG.sparkCount);

            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(size, 1));

            // Shader æè´¨ï¼šæ”¯æŒå•ç‹¬æ§åˆ¶æ¯ä¸ªç²’å­çš„å¤§å°
            const material = new THREE.ShaderMaterial({
                uniforms: { tex: { value: createGlowTexture() } },
                vertexShader: `
                    attribute float size; varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                        gl_PointSize = size * ( 300.0 / -mvPosition.z );
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tex; varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4( vColor, 1.0 ) * texture2D( tex, gl_PointCoord );
                    }
                `,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });

            sparkParticles = new THREE.Points(geometry, material);
            scene.add(sparkParticles);

            // åˆå§‹åŒ–ç‰©ç†æ±  (éšè—åœ¨è¿œå¤„)
            for(let i=0; i<CONFIG.sparkCount; i++) {
                pos[i*3] = 9999;
                sparkData.push({
                    active: false,
                    life: 0,
                    velocity: new THREE.Vector3(0,0,0) // çœŸæ­£çš„ç‰©ç†é€Ÿåº¦çŸ¢é‡
                });
            }
        }

        // === åŠ¨ç”»å¾ªç¯ (ç‰©ç†å¼•æ“) ===
        function animate() {
            requestAnimationFrame(animate);

            // 1. éŸ³é¢‘åˆ†æ
            let bass = 0, treble = 0;
            if (analyser && isAudioInit) {
                analyser.getByteFrequencyData(dataArray);
                bass = (dataArray.slice(0, 5).reduce((a,b)=>a+b)/5) / 255;
                treble = (dataArray.slice(20, 40).reduce((a,b)=>a+b)/20) / 255;
            }

            // 2. äº¤äº’å°„çº¿æ£€æµ‹ (å¼ºåˆ¶ä¸ Z=0 å¹³é¢ç›¸äº¤ï¼Œç¡®ä¿é¼ æ ‡ä½ç½®æ°¸è¿œæœ‰æ•ˆ)
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(planeZ, mouse3D);

            // è®¡ç®—é¼ æ ‡é€Ÿåº¦ï¼Œç”¨äºå†³å®šç«èŠ±å–·å°„é‡
            const mouseSpeed = mouse3D.distanceTo(lastMouse3D);
            lastMouse3D.copy(mouse3D);

            // å¦‚æœåœ¨è§¦æ‘¸ä¸”ç§»åŠ¨ï¼Œæ ¹æ®é€Ÿåº¦å–·å°„ç«èŠ± (é€Ÿåº¦è¶Šå¿«ï¼Œå–·å¾—è¶Šå¤š)
            if (isInteracting && mouseSpeed > 0.1) {
                const count = Math.min(Math.floor(mouseSpeed * 20), 10); // åŠ¨æ€æ•°é‡
                spawnSparkBurst(mouse3D, count);
            }

            // === æ›´æ–°ä¸»ä½“ç²’å­ ===
            const pPos = particles.geometry.attributes.position.array;
            const pCol = particles.geometry.attributes.color.array;

            for(let i=0; i<CONFIG.particleCount; i++) {
                const d = particleData[i];
                const ix = i*3;

                // éŸ³ä¹å¾‹åŠ¨ç›®æ ‡è®¡ç®—
                let tx = d.home.x * (1 + bass * 0.4);
                let ty = d.home.y * (1 + bass * 0.15);
                let tz = d.home.z * (1 + bass * 0.4);

                // ç£åœºæ–¥åŠ› (Physics)
                if (isInteracting) {
                    const dx = pPos[ix] - mouse3D.x;
                    const dy = pPos[ix+1] - mouse3D.y;
                    const dz = pPos[ix+2] - mouse3D.z;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    
                    if (distSq < 60) {
                        const dist = Math.sqrt(distSq);
                        const force = (60 - distSq) / 60; // 0~1
                        // æ–¥åŠ›æ¨å¼€
                        tx += (dx/dist) * force * 6;
                        ty += (dy/dist) * force * 6;
                        tz += (dz/dist) * force * 6;
                    }
                }

                // ç¼“åŠ¨å½’ä½
                pPos[ix] += (tx - pPos[ix]) * 0.1;
                pPos[ix+1] += (ty - pPos[ix+1]) * 0.1;
                pPos[ix+2] += (tz - pPos[ix+2]) * 0.1;

                // é¢œè‰²é—ªçƒ
                if (d.isOrnament && treble > 0.4) {
                    pCol[ix]=1; pCol[ix+1]=1; pCol[ix+2]=1;
                } else {
                    pCol[ix] += (d.baseColor.r - pCol[ix]) * 0.05;
                    pCol[ix+1] += (d.baseColor.g - pCol[ix+1]) * 0.05;
                    pCol[ix+2] += (d.baseColor.b - pCol[ix+2]) * 0.05;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;

            // === æ›´æ–°ç«èŠ±ç²’å­ (ç‰›é¡¿ç‰©ç†) ===
            updateSparks();

            controls.update();
            renderer.render(scene, camera);
        }

        // === ç‰©ç†ç«èŠ±ç³»ç»Ÿ ===
        function spawnSparkBurst(center, count) {
            let spawned = 0;
            for(let i=0; i<CONFIG.sparkCount; i++) {
                if(spawned >= count) break;
                const s = sparkData[i];
                if(!s.active) {
                    s.active = true;
                    s.life = 1.0;
                    
                    // åˆå§‹ä½ç½®ï¼šé¼ æ ‡ä¸­å¿ƒ + å°‘é‡éšæœºæŠ–åŠ¨
                    const pArr = sparkParticles.geometry.attributes.position.array;
                    pArr[i*3] = center.x + (Math.random()-0.5);
                    pArr[i*3+1] = center.y + (Math.random()-0.5);
                    pArr[i*3+2] = center.z + (Math.random()-0.5);

                    // åˆå§‹é€Ÿåº¦ï¼šçˆ†ç‚¸å‘å››å‘¨æ‰©æ•£ (Explosion Velocity)
                    s.velocity.set(
                        (Math.random()-0.5) * 0.5,
                        (Math.random()-0.5) * 0.5, 
                        (Math.random()-0.5) * 0.5
                    );

                    // é¢œè‰²ï¼šé‡‘è‰²/æ©™è‰²éšæœº
                    const cArr = sparkParticles.geometry.attributes.color.array;
                    cArr[i*3] = 1.0;
                    cArr[i*3+1] = 0.5 + Math.random()*0.5; // é‡‘é»„
                    cArr[i*3+2] = 0.0;

                    // å¤§å°éšæœº
                    sparkParticles.geometry.attributes.size.array[i] = Math.random()*3 + 2;
                    spawned++;
                }
            }
        }

        function updateSparks() {
            const pArr = sparkParticles.geometry.attributes.position.array;
            const sArr = sparkParticles.geometry.attributes.size.array;
            
            for(let i=0; i<CONFIG.sparkCount; i++) {
                const s = sparkData[i];
                if(!s.active) continue;

                // 1. ç”Ÿå‘½è¡°å‡
                s.life -= 0.015;
                if(s.life <= 0) {
                    s.active = false;
                    pArr[i*3] = 9999; // ç§»å‡ºè§†çº¿
                    continue;
                }

                // 2. ç‰©ç†åº”ç”¨
                // é‡åŠ› (Gravity)
                s.velocity.y -= 0.005; 
                // é˜»åŠ› (Drag)
                s.velocity.multiplyScalar(0.96);

                // 3. ä½ç½®æ›´æ–°
                pArr[i*3]   += s.velocity.x;
                pArr[i*3+1] += s.velocity.y;
                pArr[i*3+2] += s.velocity.z;

                // 4. å¤§å°éšç”Ÿå‘½å˜å°
                sArr[i] = s.life * 4;
            }
            sparkParticles.geometry.attributes.position.needsUpdate = true;
            sparkParticles.geometry.attributes.size.needsUpdate = true;
        }

        // === å½¢çŠ¶ç”Ÿæˆå™¨ ===
        function generateShape(type, colorHex) {
            const count = CONFIG.particleCount;
            const baseColorObj = new THREE.Color(colorHex);

            for (let i = 0; i < count; i++) {
                const d = particleData[i];
                let x,y,z;

                // èºæ—‹æ ‘ç®—æ³•
                if (type === 'tree') {
                    const p = i / count;
                    const angle = i * 0.15; // å¢åŠ èºæ—‹å¯†åº¦
                    const radius = (1 - p) * 9; 
                    const height = p * 24 - 12;
                    // å¢åŠ æ ‘çš„éšæœºæŠ–åŠ¨ï¼Œæ›´åƒè‡ªç„¶é’ˆå¶
                    x = Math.cos(angle) * radius + (Math.random()-0.5)*0.8;
                    z = Math.sin(angle) * radius + (Math.random()-0.5)*0.8;
                    y = height;
                } 
                // ç¯ç¬¼ç®—æ³•
                else if (type === 'lantern') {
                    const phi = Math.acos(-1 + (2 * i) / count);
                    const theta = Math.sqrt(count * Math.PI) * phi;
                    const r = 8;
                    x = r * Math.cos(theta) * Math.sin(phi);
                    y = r * Math.sin(theta) * Math.sin(phi);
                    z = r * Math.cos(phi);
                } 
                // è›‹ç³•/çˆ±å¿ƒ (ç®€æ˜“)
                else {
                     // é»˜è®¤ä¸ºçƒä½“æ•£å¸ƒ
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = 8;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }

                d.home.set(x,y,z);

                // é¢œè‰²åˆ†é… (15% è£…é¥°ç‰©)
                if (Math.random() < 0.15) {
                    const r = Math.random();
                    if(r<0.33) d.baseColor.set('#ff3355');
                    else if(r<0.66) d.baseColor.set('#ffdd00');
                    else d.baseColor.set('#33ccff');
                    d.isOrnament = true;
                } else {
                    d.baseColor.copy(baseColorObj);
                    // åŸºç¡€è‰²åŠ ä¸Šäº®åº¦å™ªç‚¹ï¼Œæ›´æœ‰è´¨æ„Ÿ
                    d.baseColor.multiplyScalar(0.3 + Math.random()*0.7);
                    d.isOrnament = false;
                }
            }
        }

        // === äº¤äº’äº‹ä»¶ (å…¼å®¹ PC å’Œ Mobile) ===
        function onMove(e) {
            isInteracting = true;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            resetInteractTimer();
        }
        function onTouchMove(e) {
            e.preventDefault();
            isInteracting = true;
            mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            resetInteractTimer();
        }
        let interactTimer;
        function resetInteractTimer() {
            clearTimeout(interactTimer);
            interactTimer = setTimeout(() => isInteracting = false, 100);
        }

        function createGlowTexture() {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.4,'rgba(255,255,255,0.2)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
            const t = new THREE.Texture(c); t.needsUpdate=true; return t;
        }

        function getFormattedDate() {
            const d = new Date(); return `${('0'+(d.getMonth()+1)).slice(-2)}-${('0'+d.getDate()).slice(-2)}`;
        }
        
        function initAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser(); analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                navigator.mediaDevices.getUserMedia({ audio: true }).then(s => {
                    audioCtx.createMediaStreamSource(s).connect(analyser);
                }).catch(e=>console.log(e));
            } catch(e){}
        }

        // === UI é€»è¾‘ ===
        window.onWindowResize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.ui = {
            openModal: () => {
                const m = document.getElementById('modal');
                m.style.display = 'block';
                setTimeout(()=>m.classList.add('active'), 10);
            },
            closeModal: () => {
                const m = document.getElementById('modal');
                m.classList.remove('active');
                setTimeout(()=>m.style.display = 'none', 300);
            },
            onThemeChange: () => {
                const t = document.getElementById('input-theme').value;
                const l = document.getElementById('label-date');
                // ä¸»é¢˜ 3 æ˜¯ç”Ÿæ—¥ï¼Œå¿…å¡«
                if(t === '3') l.innerHTML = 'ç”Ÿæ—¥æ—¥æœŸ <span class="required-mark">* (å¿…å¡«)</span>';
                else l.innerText = 'æ—¥æœŸ (MM-DD, çºªå¿µæ—¥é€‰å¡«)';
            },
            submitForm: async () => {
                const name = document.getElementById('input-name').value;
                const date = document.getElementById('input-date').value;
                const theme = document.getElementById('input-theme').value;
                const wish = document.getElementById('input-wish').value;

                if(!name) { alert('è¯·å¡«å†™å¯¹æ–¹çš„åå­—'); return; }
                if(theme === '3' && !date) { alert('ç”Ÿæ—¥ä¸»é¢˜å¿…é¡»å¡«å†™æ—¥æœŸå“¦ (ä¾‹å¦‚ 05-20)'); return; }

                const btn = document.querySelector('.submit-btn');
                const oldText = btn.innerText;
                btn.innerText = 'æ­£åœ¨ä¸Šä¼ ...';
                
                // å¦‚æœæ²¡å¡«æ—¥æœŸä¸”ä¸æ˜¯ç”Ÿæ—¥ï¼Œç»™ä¸ªé»˜è®¤å ä½ï¼Œé˜²æ­¢æŠ¥é”™
                const finalDate = date || getFormattedDate();

                const { error } = await supabase.from('private_events').insert({
                    user_key: name, event_date: finalDate, theme_id: parseInt(theme), custom_message: wish
                });

                if(error) alert('Error: ' + error.message);
                else {
                    const link = `${window.location.origin}${window.location.pathname}?to=${name}`;
                    document.getElementById('result-link').innerHTML = `åˆ¶ä½œæˆåŠŸï¼<br><a href="${link}" style="color:#ffcc00; text-decoration:none; border-bottom:1px dashed #ffcc00">${link}</a>`;
                }
                btn.innerText = oldText;
            }
        }
    </script>
</body>
</html>
