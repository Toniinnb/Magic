<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Holiday Engine: Spark & Flow</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; touch-action: none; }
        #ui-layer { position: absolute; bottom: 30px; width: 100%; text-align: center; pointer-events: none; z-index: 10; font-family: monospace; color: rgba(255,255,255,0.5); }
        #mic-btn { pointer-events: auto; background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #fff; padding: 10px 20px; border-radius: 20px; cursor: pointer; backdrop-filter: blur(5px); }
    </style>
</head>
<body>

    <div id="ui-layer">
        <button id="mic-btn">ğŸ”Š ENABLE SOUND REACTIVITY</button>
        <div style="font-size: 10px; margin-top: 5px;">TOUCH & DRAG TO IGNITE SPARKS</div>
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float uTime;
        uniform vec3 uMouse; // é¼ æ ‡ä½ç½®
        uniform float uAudio; // éŸ³é¢‘å¼ºåº¦
        
        attribute vec3 aRandom; // éšæœºå±æ€§
        attribute vec3 initialPos; // åˆå§‹ä½ç½®

        varying vec3 vColor;
        varying float vSparkle;

        // ä¼ªéšæœºå‡½æ•°
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        void main() {
            vec3 pos = initialPos;
            
            // 1. åŸºç¡€åŠ¨æ€ï¼šé£å¹æ ‘å¶ (æ ¹æ®é«˜åº¦ä¸åŒï¼Œæ‘†åŠ¨å¹…åº¦ä¸åŒ)
            float wind = sin(uTime * 0.5 + pos.y * 0.5) * 0.1 * (pos.y + 5.0) * 0.1;
            pos.x += wind;

            // 2. å£°éŸ³éœ‡åŠ¨ï¼šæ•´ä½“è†¨èƒ€
            pos += normalize(pos) * uAudio * 0.5;

            // 3. æ ¸å¿ƒäº¤äº’ï¼šç£åœºä¸ç«èŠ± (Interaction)
            // è®¡ç®—ç²’å­ä¸é¼ æ ‡çš„è·ç¦» (åœ¨ xy å¹³é¢)
            float dist = distance(pos.xy, uMouse.xy);
            float radius = 3.0; // äº¤äº’åŠå¾„
            
            float activation = 0.0; // æ¿€æ´»ç¨‹åº¦ (0 = æ— , 1 = å¼º)

            if(dist < radius) {
                // åŠ›çš„è®¡ç®—ï¼šè¶Šè¿‘åŠ›è¶Šå¤§
                float force = (radius - dist) / radius;
                force = pow(force, 2.0); // æŒ‡æ•°çº§å¢å¼ºï¼Œæ›´æœ‰çˆ†å‘æ„Ÿ
                
                // æ–¥åŠ›æ–¹å‘
                vec3 dir = normalize(pos - uMouse);
                
                // çˆ†ç‚¸æ•ˆæœï¼šç²’å­è¢«çŒ›çƒˆæ¨å¼€
                pos += dir * force * 5.0;
                
                // è®°å½•æ¿€æ´»å€¼ä¼ ç»™ç‰‡å…ƒç€è‰²å™¨ (ç”¨äºå˜è‰²)
                activation = force;
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            
            // 4. ç²’å­å¤§å°æ§åˆ¶
            // æ¿€æ´»æ—¶å˜å¤§(ç«èŠ±)ï¼Œå¹³æ—¶æ ¹æ®è·ç¦»è¡°å‡
            float baseSize = 80.0 * (1.0 + uAudio);
            float sparkSize = activation * 200.0; // ç«èŠ±ç²’å­å·¨å¤§
            gl_PointSize = (baseSize + sparkSize) * aRandom.x / -mvPosition.z;

            gl_Position = projectionMatrix * mvPosition;

            // 5. é¢œè‰²ä¼ é€’
            // é»˜è®¤é¢œè‰² (ç¥–æ¯ç»¿ + é‡‘è‰²) vs ç«èŠ±é¢œè‰² (ç™½çƒ­åŒ– + æ©™çº¢)
            vec3 baseColor = mix(vec3(0.1, 0.4, 0.2), vec3(1.0, 0.8, 0.2), aRandom.y); // éšæœºé‡‘/ç»¿
            vec3 sparkColor = mix(vec3(1.0, 0.3, 0.0), vec3(1.0, 1.0, 1.0), activation); // æ©™ -> ç™½
            
            vColor = mix(baseColor, sparkColor, activation); // æ ¹æ®æ¿€æ´»åº¦æ··åˆé¢œè‰²
            vSparkle = activation; // ä¼ é€’ç»™ç‰‡å…ƒåšè¾‰å…‰
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vColor;
        varying float vSparkle;

        void main() {
            // ç»˜åˆ¶æŸ”å’Œçš„åœ†å½¢ç²’å­
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            
            if (dist > 0.5) discard;

            // å¾„å‘æ¸å˜ï¼šä¸­å¿ƒäº®ï¼Œè¾¹ç¼˜é€æ˜
            float alpha = 1.0 - smoothstep(0.1, 0.5, dist);
            
            // å¦‚æœæ˜¯ç«èŠ±çŠ¶æ€ï¼Œæ›´äº®
            float intensity = 1.0 + vSparkle * 2.0;
            
            gl_FragColor = vec4(vColor * intensity, alpha * 0.8);
        }
    </script>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 12;
        camera.position.y = 1;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ æ¯”ï¼Œæå‡ç§»åŠ¨ç«¯æ€§èƒ½
        document.body.appendChild(renderer.domElement);

        // --- æ ¸å¿ƒï¼šæ ‘å½¢æ„å»º (é¿å…åƒå¤§ä¾¿) ---
        // é€»è¾‘ï¼šä½¿ç”¨åˆ†å±‚èºæ—‹ (Layered Spirals)
        const particleCount = 20000;
        const geometry = new THREE.BufferGeometry();
        const initialPos = [];
        const randoms = [];

        // æ ‘çš„å‚æ•°
        const layers = 60; // å¢åŠ å±‚æ•°ï¼Œè®©å®ƒæ›´å¯†
        const particlesPerLayer = particleCount / layers;

        for (let i = 0; i < particleCount; i++) {
            // è®¡ç®—å½“å‰ç²’å­å±äºå“ªä¸€å±‚
            const layerIndex = Math.floor(i / particlesPerLayer);
            const layerProgress = layerIndex / layers; // 0 (é¡¶) -> 1 (åº•)
            
            // é«˜åº¦åˆ†å¸ƒ (çº¿æ€§ -> æŒ‡æ•°ï¼Œè®©é¡¶éƒ¨å°–é”ï¼Œåº•éƒ¨å®½å¤§)
            const y = 6.0 - (layerProgress * 12.0); 
            
            // è¿™ä¸€å±‚çš„åŠå¾„ (åœ†é”¥å½¢)
            // ä½¿ç”¨ Math.pow è®©å½¢çŠ¶å†…å‡¹ï¼Œæ›´åƒæ¾æ ‘è€Œä¸æ˜¯ä¸‰è§’å½¢
            const maxRadius = Math.pow(layerProgress, 1.2) * 5.5; 

            // åœ¨å±‚å†…åˆ†å¸ƒï¼šä½¿ç”¨é»„é‡‘è§’åº¦èºæ—‹ï¼Œé˜²æ­¢èšé›†æˆå›¢
            const angle = i * 2.39996; // é»„é‡‘è§’å¼§åº¦
            const r = Math.sqrt(Math.random()) * maxRadius; // å‡åŒ€åˆ†å¸ƒåœ¨åœ†å†…
            
            // å…³é”®ï¼šåŠ å…¥â€œæä¸«â€æ„Ÿ
            // åªæœ‰å½“ç²’å­åœ¨ç‰¹å®šçš„è§’åº¦ç°‡æ—¶æ‰ä¿ç•™ï¼Œå½¢æˆåƒæ˜Ÿæ˜Ÿä¸€æ ·çš„è¾å°„çŠ¶
            const branchNoise = Math.sin(angle * 7.0 + layerIndex * 0.5); // 7ä¸ªä¸»åˆ†å‰
            // å¦‚æœä¸åœ¨æä¸«ä¸Šï¼Œå°±æ¨å‘ä¸­å¿ƒï¼ˆåšæ ‘å¹²ï¼‰
            const finalR = (branchNoise > 0.0) ? r : r * 0.2; 

            const x = Math.cos(angle) * finalR;
            const z = Math.sin(angle) * finalR;

            initialPos.push(x, y, z);
            
            // éšæœºæ•°ï¼šx=å¤§å°å˜åŒ–, y=é¢œè‰²æ··åˆ, z=é—ªçƒç›¸ä½
            randoms.push(Math.random(), Math.random(), Math.random());
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(initialPos, 3)); // è¿™æ˜¯ä¸€ä¸ªå ä½ç¬¦ï¼ŒçœŸæ­£è®¡ç®—åœ¨Shader
        geometry.setAttribute('initialPos', new THREE.Float32BufferAttribute(initialPos, 3));
        geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 3));

        // --- æè´¨ (Shader) ---
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMouse: { value: new THREE.Vector3(999, 999, 0) }, // åˆå§‹åœ¨å±å¹•å¤–
                uAudio: { value: 0 }
            },
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending // å¼ºå…‰å åŠ æ¨¡å¼ -> é…·ç‚«æ„Ÿæ¥æº
        });

        const tree = new THREE.Points(geometry, material);
        scene.add(tree);

        // --- äº¤äº’ç³»ç»Ÿ (é¼ æ ‡ + è§¦æ‘¸) ---
        const mousePlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const raycaster = new THREE.Raycaster();
        const screenMouse = new THREE.Vector2();
        
        // å¹³æ»‘ç§»åŠ¨çš„ç›®æ ‡å€¼ (ç”¨äºé˜»å°¼æ•ˆæœ)
        const targetMousePos = new THREE.Vector3(999, 999, 0); 
        const currentMousePos = new THREE.Vector3(999, 999, 0);

        function updateInput(x, y) {
            screenMouse.x = (x / window.innerWidth) * 2 - 1;
            screenMouse.y = -(y / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(screenMouse, camera);
            raycaster.ray.intersectPlane(mousePlane, targetMousePos);
        }

        // PC
        window.addEventListener('mousemove', (e) => updateInput(e.clientX, e.clientY));
        
        // Mobile (Touch)
        window.addEventListener('touchmove', (e) => {
            e.preventDefault(); // é˜²æ­¢æ»šåŠ¨
            updateInput(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        // å…³é”®ä¿®å¤ï¼šè§¦æ‘¸ç»“æŸæ—¶ï¼Œç§»èµ°ç£åœº
        window.addEventListener('touchend', () => {
            targetMousePos.set(999, 999, 0); // ç¬ç§»åˆ°å¾ˆè¿œçš„åœ°æ–¹
        });

        // --- éŸ³é¢‘ç³»ç»Ÿ ---
        let analyser, dataArray;
        document.getElementById('mic-btn').addEventListener('click', async (e) => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const source = ctx.createMediaStreamSource(stream);
                analyser = ctx.createAnalyser();
                analyser.fftSize = 64;
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                e.target.style.display = 'none'; // éšè—æŒ‰é’®
            } catch(err) {
                alert("Mic Access Denied");
            }
        });

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;
            material.uniforms.uTime.value = time;

            // 1. é¼ æ ‡ä½ç½®çš„å¹³æ»‘æ’å€¼ (é˜»å°¼æ„Ÿ)
            // æ¯æ¬¡åªç§»åŠ¨ 10% çš„è·ç¦» -> çœ‹èµ·æ¥æœ‰æƒ¯æ€§
            currentMousePos.lerp(targetMousePos, 0.1); 
            material.uniforms.uMouse.value.copy(currentMousePos);

            // 2. éŸ³é¢‘å¤„ç†
            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                const avg = dataArray.reduce((a,b)=>a+b,0) / dataArray.length;
                // è¡°å‡åŠ¨ç”»
                const targetAudio = avg / 128.0;
                material.uniforms.uAudio.value += (targetAudio - material.uniforms.uAudio.value) * 0.2;
            }

            // 3. ææ…¢çš„è‡ªè½¬ï¼Œå¢åŠ ç«‹ä½“æ„Ÿ
            tree.rotation.y = Math.sin(time * 0.1) * 0.1; 

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
